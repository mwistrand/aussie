# Appendix D: Architecture Decision Record Log

This appendix documents the significant architectural decisions visible in the Aussie API Gateway codebase. Each entry follows the Architecture Decision Record (ADR) format: context, decision, consequences, and pointers to the code that implements it.

These are not hypothetical decisions. Every one of them is enforced by running code, tests, or both. If you want to understand why the codebase looks the way it does -- why records instead of classes, why sealed interfaces instead of exceptions, why ServiceLoader instead of CDI discovery -- this is the reference.

---

## ADR-001: Hexagonal Architecture with ArchUnit Enforcement

**Status:** Accepted

**Context:** An API gateway is infrastructure that outlives any single framework. It handles authentication, rate limiting, CORS, WebSocket proxying, token translation, RBAC, and a dozen other concerns that each have their own evolution timeline. If the domain logic is entangled with Quarkus, Vert.x, or Cassandra, then changing any infrastructure dependency means rewriting business logic. The team needed a structure where the core domain compiles and tests without any framework on the classpath.

**Decision:** Organize the codebase into three layers with strict, unidirectional dependency flow: `core/` (models, ports, services), `adapter/` (driving and driven adapters), and `system/` (cross-cutting filters). Enforce the dependency rules at build time using ArchUnit tests that fail the build on violation.

**Consequences:**
- The core layer has zero dependency on Jakarta, Quarkus, Vert.x, Cassandra, or Redis. Domain services can be unit tested with plain JUnit and Mockito in milliseconds.
- There is meaningful indirection. `GatewayService` calls `ProxyClient`, not `ProxyHttpClient`. Reading code requires following the interface to its implementation in the adapter layer.
- The package count is high (nine subdirectories under `core/model` alone), which can feel over-structured to engineers unfamiliar with hexagonal architecture. The counterargument is that the structure is self-documenting.
- Outbound ports (`core/port/out/`) are enforced as interfaces only -- no concrete classes allowed in that package.
- Models (`core/model/`) cannot depend on services (`core/service/`) or ports (`core/port/`), preventing circular dependencies.

**Evidence in code:**

- `api/src/test/java/aussie/HexagonalArchitectureTest.java` -- ArchUnit rules enforcing:
  - `core..` must not depend on `adapter..` (line 34-41)
  - `core..` must not depend on `system..` (line 48-54)
  - `adapter..` must not depend on `system..` (line 65-72)
  - Outbound ports must be interfaces (line 152-158)
  - Models must not depend on services (line 169-174)
  - Models must not depend on ports (line 180-188)
- `api/src/main/java/aussie/core/port/out/ProxyClient.java` -- A port interface that `GatewayService` depends on, implemented by `ProxyHttpClient` in the adapter layer
- `api/src/main/java/aussie/core/port/in/GatewayUseCase.java` -- Inbound port interface returning `Uni<GatewayResult>`, implemented by `GatewayService`

---

## ADR-002: Java Records for Domain Models Instead of POJOs/Lombok

**Status:** Accepted

**Context:** The domain model contains dozens of types representing services, endpoints, tokens, rate limits, authentication contexts, and configuration. These types need to be immutable, equality-comparable, and serializable. The traditional approach uses POJOs with getters, constructors, `equals`/`hashCode`, and `toString` -- either hand-written or generated by Lombok. The project targets Java 21.

**Decision:** Use Java records for all domain model types. Use compact constructors for validation and defensive copying. Use `with*` methods that return new instances for controlled mutation.

**Consequences:**
- Immutability is guaranteed by the language. Records cannot have mutable fields, and the compiler generates `equals`, `hashCode`, and `toString` automatically.
- Compact constructors serve as the validation layer. `ServiceRegistration`'s compact constructor validates required fields, assigns defaults (e.g., `defaultVisibility = EndpointVisibility.PRIVATE`), and normalizes nulls to `Optional.empty()` -- all in a single block that runs on every construction.
- No Lombok dependency. One less annotation processor, one less build plugin, one less thing that breaks during upgrades.
- Records with many fields (e.g., `ServiceRegistration` with 14 parameters) become unwieldy. The codebase addresses this with a `Builder` nested class inside the record for construction, while keeping the record itself as the immutable product.
- Records cannot be extended, which is appropriate for value types but means you cannot create specialized subtypes through inheritance. Sealed interfaces fill this gap for algebraic data types.

**Evidence in code:**

- `api/src/main/java/aussie/core/model/service/ServiceRegistration.java` -- 14-field record with compact constructor validation (lines 68-108), `Builder` inner class (lines 278-385), and `with*` methods for controlled mutation (lines 113-192)
- `api/src/main/java/aussie/core/model/auth/Principal.java` -- Record with compact constructor defaults (line 15-28) and factory methods (lines 30-41)
- `api/src/main/java/aussie/core/model/auth/ApiKey.java` -- Record with `isValid()` logic (line 62-64), `redacted()` (line 71-73), and `revoke()` (line 80-82) methods that return new instances
- `api/src/main/java/aussie/core/model/ratelimit/RateLimitKey.java` -- Record with factory methods `http()`, `wsConnection()`, `wsMessage()` and a `toCacheKey()` method
- `api/src/main/java/aussie/core/model/ratelimit/RateLimitDecision.java` -- Record with static factory methods `allow()` and `rejected()` instead of constructors

---

## ADR-003: Sealed Interfaces for Result Types Instead of Exceptions

**Status:** Accepted

**Context:** A gateway has many operations with multiple possible outcomes that are not exceptional. Authentication can succeed, fail, or be skipped. A route lookup can match exactly, match a service but no endpoint, or match nothing. Token validation can produce a valid result, an invalid result, or a "no token present" result. Using exceptions for these cases conflates control flow with error handling, obscures the set of possible outcomes, and makes it easy to forget to handle a case.

**Decision:** Use Java 21 sealed interfaces to model operation results as algebraic data types. Each sealed interface enumerates its permitted implementations as records. Consumers use pattern matching (switch expressions or `instanceof` patterns) to handle each case.

**Consequences:**
- The compiler enforces exhaustiveness. If a new variant is added to `GatewayResult`, every `switch` statement over it will fail to compile until it handles the new case.
- The set of possible outcomes is documented in the type system. Opening `AuthenticationResult.java` shows exactly three possibilities: `Success`, `Failure`, `Skip`. There is no need to search for `throws` clauses or catch blocks.
- Exception-based control flow is eliminated for expected outcomes. Exceptions are reserved for truly exceptional situations (SHA-256 algorithm not available, null pointer bugs).
- Pattern matching syntax in Java 21 is less ergonomic than languages with native sum types. Some switch expressions become verbose.
- Stack traces are not generated for expected failures, which is a performance benefit in a high-throughput gateway.

**Evidence in code:**

- `api/src/main/java/aussie/core/model/gateway/GatewayResult.java` -- Eight variants: `Success`, `RouteNotFound`, `ServiceNotFound`, `ReservedPath`, `Error`, `Unauthorized`, `Forbidden`, `BadRequest` (lines 6-36)
- `api/src/main/java/aussie/core/model/auth/AuthenticationResult.java` -- Three variants: `Success(AuthenticationContext)`, `Failure(String reason, int statusCode)`, `Skip()` with singleton pattern (lines 11-61)
- `api/src/main/java/aussie/core/model/auth/TokenValidationResult.java` -- Three variants: `Valid`, `Invalid`, `NoToken` (lines 9-45)
- `api/src/main/java/aussie/core/model/gateway/RouteAuthResult.java` -- Five variants: `Authenticated`, `NotRequired`, `Unauthorized`, `Forbidden`, `BadRequest` (lines 10-53)
- `api/src/main/java/aussie/core/model/service/RegistrationResult.java` -- Two variants: `Success(ServiceRegistration)`, `Failure(String reason, int statusCode)` (lines 8-45)
- `api/src/main/java/aussie/core/model/common/ValidationResult.java` -- Two variants with convenience methods: `valid()`, `invalid()`, `payloadTooLarge()`, `headerTooLarge()` (lines 3-32)
- `api/src/main/java/aussie/core/model/routing/RouteLookupResult.java` -- Two variants with shared default methods for `visibility()`, `authRequired()`, `rateLimitConfig()` (lines 24-98)
- `api/src/main/java/aussie/core/model/auth/RevocationEvent.java` -- Two variants: `JtiRevoked`, `UserRevoked` (sealed interface used in pattern matching at `RevocationBloomFilter.java` line 121-130)
- `api/src/main/java/aussie/core/model/websocket/WebSocketUpgradeResult.java` -- Sealed interface for WebSocket upgrade outcomes

---

## ADR-004: Caffeine Local Cache with TTL Jitter Instead of Fixed TTL

**Status:** Accepted

**Context:** In a multi-instance deployment, every gateway instance maintains a local cache of service registrations, JWKS keys, and revocation data. If all instances use the same fixed TTL, their caches expire at roughly the same time. When that happens, every instance simultaneously hits the backend storage to refresh -- a "cache stampede" or "thundering herd" that can overwhelm Cassandra or Redis during normal operation.

**Decision:** Use Caffeine as the local cache implementation with a custom `Expiry` that adds random jitter to each entry's TTL. The jitter factor is configurable (default plus-or-minus 10%), spreading cache refreshes across time.

**Consequences:**
- Cache refreshes are naturally distributed across a window instead of clustering at a single point. With 10 instances and a 5-minute TTL, refreshes spread across a 1-minute window instead of all hitting at second 300.
- The jitter implementation uses `ThreadLocalRandom`, which is lock-free and adds negligible overhead per cache write.
- The jitter factor is bounded (0.0 to 0.5) to prevent pathological configurations. Zero disables jitter and falls back to Caffeine's native `expireAfterWrite`.
- Cache entries may expire slightly before or after the nominal TTL, meaning data staleness varies slightly between instances. This is acceptable for a system that is already eventually consistent.

**Evidence in code:**

- `api/src/main/java/aussie/core/cache/CaffeineLocalCache.java` -- Full implementation:
  - `DEFAULT_JITTER_FACTOR = 0.1` (line 31)
  - `JitteredExpiry` inner class implementing Caffeine's `Expiry<K, V>` interface (lines 80-101)
  - `applyJitter()` method: `jitterMultiplier = 1.0 - jitterFactor + random * 2 * jitterFactor` (lines 96-101)
  - Jitter factor validation in constructor (lines 56-58)
  - Zero-jitter path using simple `expireAfterWrite` (lines 63-67)
- `api/src/main/java/aussie/core/cache/LocalCache.java` -- Generic cache interface in the core layer, decoupled from Caffeine (lines 17-66)
- `api/src/test/java/aussie/core/cache/CaffeineLocalCacheTest.java` -- Tests for jitter behavior and cache semantics

---

## ADR-005: Bloom Filter for Token Revocation Instead of Direct Lookups

**Status:** Accepted

**Context:** Every authenticated request must check whether its token has been revoked. In a gateway processing thousands of requests per second, a network round-trip to Redis or Cassandra on every request adds latency and creates a hard dependency on storage availability. The vast majority of tokens are not revoked -- typically 99.9% or more. The system needs a way to skip the expensive remote lookup for the common case.

**Decision:** Implement a tiered revocation check with a Guava BloomFilter as the first tier. The bloom filter provides O(1) "definitely not revoked" checks at approximately 100 nanoseconds with no network I/O. Tokens that pass the bloom filter (not in the set) skip all further checks. Tokens that might be revoked (bloom filter says "maybe") proceed to a local LRU cache, and then to the remote store.

**Consequences:**
- The hot path (token is not revoked) costs approximately 100ns and zero network I/O. This is critical for a gateway where every millisecond of latency multiplies across all downstream consumers.
- The bloom filter has a configurable false positive rate (default 0.1%). False positives cause unnecessary remote lookups but never cause incorrect results. There are no false negatives -- if the bloom filter says "definitely not," the token is definitely not revoked.
- The filter must be rebuilt periodically from the remote store to handle instance restarts and cross-instance consistency. This is scheduled on a configurable interval using Vert.x periodic timers.
- The tiered approach (TTL shortcut, bloom filter, local cache, remote store) means four code paths to test and monitor. The `TokenRevocationService` javadoc explicitly documents the performance targets: P50 under 100 microseconds, P99 under 500 microseconds, P99.9 under 5 milliseconds.
- Separate bloom filters are maintained for JTI-level and user-level revocations, since user-level revocations are expected to be an order of magnitude less frequent.

**Evidence in code:**

- `api/src/main/java/aussie/core/service/auth/RevocationBloomFilter.java` -- Full implementation:
  - Guava `BloomFilter<CharSequence>` with configurable expected insertions and false positive probability (lines 43-44, 84-86, 93-95)
  - `definitelyNotRevoked(String jti)` and `userDefinitelyNotRevoked(String userId)` methods (lines 142-159)
  - `rebuildFilters()` method that streams all revoked entries from the remote store and atomically swaps filters under a write lock (lines 198-228)
  - Periodic rebuild scheduling via `vertx.setPeriodic()` (lines 97-105)
  - Pub/sub subscription for real-time bloom filter updates from other instances (lines 107-130)
- `api/src/main/java/aussie/core/service/auth/TokenRevocationService.java` -- Tiered lookup orchestration:
  - Tier 0: TTL shortcut for soon-expiring tokens (lines 76-80)
  - Tier 1: Bloom filter check (lines 85-93)
  - Tier 2: Local cache check (lines 96-112)
  - Tier 3: Remote store lookup (line 115)
  - Performance target documentation in javadoc (lines 28-32)
- `api/src/main/java/aussie/core/service/auth/RevocationCache.java` -- Tier 2 local LRU cache for confirmed revocations, using Caffeine with configurable max size and TTL (lines 36-213)

---

## ADR-006: SPI (ServiceLoader) for Storage Backends Instead of CDI-Only

**Status:** Accepted

**Context:** An API gateway sits at the intersection of every team's infrastructure. The authentication team wants Vault. The platform team runs DynamoDB instead of Cassandra. The observability group uses Datadog instead of Prometheus. These teams will never be in the same room when they decide to integrate. They need a contract-based extension mechanism that does not require modifying the gateway source code or understanding CDI.

**Decision:** Define provider interfaces in a dedicated `aussie.spi` package. Implementations are discovered via `java.util.ServiceLoader` and registered through `META-INF/services` files. Each provider has a `name()`, `priority()`, and `isAvailable()` method. When no explicit provider is configured, the highest-priority available provider is selected automatically.

**Consequences:**
- External teams can add a storage backend by implementing an interface, creating a `META-INF/services` file, and dropping a JAR on the classpath. No CDI annotations, no Quarkus extensions, no source modifications.
- Built-in providers (in-memory at priority 0, Cassandra at priority 10) are automatically superseded by custom providers at higher priority. This allows a graceful transition from development (in-memory) to production (Cassandra) to customized (DynamoDB at priority 20) without configuration changes.
- The SPI layer is independent from CDI. The `StorageProviderLoader` bridges between ServiceLoader discovery and CDI bean production via `@Produces` methods. This means the provider implementations themselves do not need to be CDI beans.
- There are 10+ SPI interfaces covering different concerns: `StorageRepositoryProvider`, `AuthKeyStorageProvider`, `ConfigurationCacheProvider`, `AuthKeyCacheProvider`, `RateLimiterProvider`, `RoleStorageProvider`, `SecurityEventHandler`, `SamplingConfigProvider`, and more. Each can be independently replaced.
- The indirection adds a startup-time cost (ServiceLoader scanning) that is negligible but present. Provider selection is logged at INFO level for operational visibility.

**Evidence in code:**

- `api/src/main/java/aussie/spi/StorageRepositoryProvider.java` -- SPI interface with `name()`, `description()`, `priority()`, `isAvailable()`, `createRepository()`, and optional `createHealthIndicator()` (lines 38-108)
- `api/src/main/java/aussie/spi/AuthKeyStorageProvider.java` -- Parallel SPI for API key storage, separate from service registration storage (lines 43-113)
- `api/src/main/java/aussie/adapter/out/storage/StorageProviderLoader.java` -- Bridge between ServiceLoader and CDI:
  - `ServiceLoader.load(StorageRepositoryProvider.class)` discovery (line 116)
  - Priority-based selection with explicit config override (lines 163-179)
  - CDI `@Produces` methods for `ServiceRegistrationRepository`, `ConfigurationCache`, and health indicators (lines 63-108)
- `api/src/main/resources/META-INF/services/aussie.spi.StorageRepositoryProvider` -- Registers two built-in providers: `InMemoryStorageProvider` and `CassandraStorageProvider`
- `api/src/main/resources/META-INF/services/aussie.spi.AuthKeyStorageProvider` -- Registers: `InMemoryAuthKeyStorageProvider` and `CassandraAuthKeyStorageProvider`

---

## ADR-007: Vert.x RouteFilter for CORS/Security Headers Instead of JAX-RS Filters

**Status:** Accepted

**Context:** Quarkus runs on Vert.x. Incoming HTTP requests pass through the Vert.x routing layer before reaching the JAX-RS (RESTEasy Reactive) layer. The gateway proxies requests to backend services, and some of those proxy paths bypass JAX-RS entirely (WebSocket upgrades, for example). If CORS or security headers are implemented as JAX-RS `ContainerResponseFilter`s, they only apply to JAX-RS-handled requests. Proxied responses and error pages generated by Vert.x itself would lack these headers.

**Decision:** Implement CORS handling and security response headers as Vert.x `@RouteFilter` annotated methods on `@ApplicationScoped` beans. These filters operate at the Vert.x routing level, before JAX-RS, ensuring they apply to all HTTP responses regardless of how they are generated.

**Consequences:**
- CORS headers are added to every response, including proxied responses, WebSocket upgrades, health check responses, and Vert.x-generated error pages. No response leaves the gateway without proper CORS or security headers.
- Filter ordering is explicit through the priority parameter: CORS at 100, security headers at 90, WebSocket upgrade at 50. Higher priorities run first.
- The filters inject configuration via `Instance<Config>` (CDI programmatic lookup) rather than direct injection. This allows the filter to gracefully skip when configuration is not resolvable, rather than failing at startup.
- JAX-RS `@ServerRequestFilter` is still used for concerns that need JAX-RS context (rate limiting at `AUTHENTICATION - 50` priority, authentication, access control). The system uses both filter mechanisms, each for its appropriate use case.
- The pattern couples the adapter layer to Vert.x APIs (`RoutingContext`), which is acceptable since adapters are allowed to depend on framework types.

**Evidence in code:**

- `api/src/main/java/aussie/adapter/in/http/CorsFilter.java` -- CORS filter:
  - `@RouteFilter(100)` annotation (line 52)
  - `Instance<GatewayCorsConfig>` injection for safe resolution (line 41, 44)
  - Preflight handling and response header injection on `RoutingContext` (lines 53-91)
- `api/src/main/java/aussie/adapter/in/http/SecurityHeadersFilter.java` -- Security headers filter:
  - `@RouteFilter(90)` annotation (line 38)
  - OWASP-recommended headers: `X-Content-Type-Options`, `X-Frame-Options`, `Content-Security-Policy`, `Referrer-Policy`, `Strict-Transport-Security`, `Permissions-Policy` (lines 54-61)
- `api/src/main/java/aussie/adapter/in/websocket/WebSocketUpgradeFilter.java` -- WebSocket upgrade filter at `@RouteFilter(50)`
- `api/src/main/java/aussie/system/filter/RateLimitFilter.java` -- Contrast: uses `@ServerRequestFilter` (JAX-RS level) because it needs `ContainerRequestContext` and `HttpServerRequest` (line 101-102)

---

## ADR-008: Token Hashing for Rate Limit Keys Instead of Raw Tokens

**Status:** Accepted

**Context:** Rate limiting requires a stable client identifier to track request counts. When the client authenticates with a Bearer token, the token itself could serve as the key. However, storing raw tokens as rate limit keys means they appear in Redis, in log files, in metrics labels, and in error messages. A single log aggregation misconfiguration or Redis snapshot could expose thousands of valid authentication tokens.

**Decision:** Hash bearer tokens using SHA-256 before using them as rate limit keys. The hash is truncated to 16 hex characters (64 bits of entropy), which is sufficient for rate limit keying while keeping cache keys compact. A dedicated `SecureHash` utility class provides the hashing.

**Consequences:**
- Bearer tokens never appear in Redis keys, log output, metrics labels, or security event payloads. An attacker who compromises the rate limiter's data store gains no usable authentication material.
- The truncated hash (16 hex characters) provides 64 bits of collision resistance. For rate limiting purposes, this is far more than sufficient -- a collision would mean two different tokens share a rate limit bucket, which is a minor fairness issue, not a security issue.
- The hashing adds approximately 1 microsecond per request (SHA-256 of a typical JWT). This is negligible relative to the network round-trip for the rate limit check itself.
- The same `SecureHash.truncatedSha256()` utility is used consistently across the codebase: for rate limit keys, for client IDs in security events, and for API key storage.

**Evidence in code:**

- `api/src/main/java/aussie/core/util/SecureHash.java` -- SHA-256 hashing utility:
  - `truncatedSha256(String input, int hexChars)` method (lines 33-45)
  - Input validation: hexChars must be 1-64 (line 34-36)
  - Uses `MessageDigest.getInstance("SHA-256")` and `HexFormat` (lines 38-41)
- `api/src/main/java/aussie/system/filter/RateLimitFilter.java` -- Usage in rate limiting:
  - `hashToken(String token)` calls `SecureHash.truncatedSha256(token, 16)` (line 309)
  - `extractAuthHeaderHash()` strips the "Bearer " prefix, hashes the token, and prefixes with `"bearer:"` (lines 219-225)
  - `hashClientId()` for security event dispatching (lines 301-306)
  - Client identification priority: session > bearer token hash > API key ID > IP (lines 203-208)

---

## ADR-009: Progressive Lockout for Auth Rate Limiting Instead of Fixed Lockout

**Status:** Accepted

**Context:** Authentication endpoints are prime targets for credential stuffing and brute force attacks. A fixed lockout duration (e.g., 15 minutes after 5 failures) provides basic protection but has a weakness: a persistent attacker can simply wait out the lockout and resume. Each cycle costs the attacker only 15 minutes. At the same time, a fixed lockout can also penalize legitimate users who mistype their password a few times.

**Decision:** Implement progressive lockout where the lockout duration increases exponentially with each successive lockout for the same key. The base duration, multiplier, and maximum cap are all configurable. Failed attempts are tracked by both IP address and user identifier independently to handle distributed attacks.

**Consequences:**
- Persistent attackers face escalating costs: 15 minutes, then 22.5 minutes, then 33.75 minutes, up to the configured maximum of 24 hours. This makes sustained brute force attacks economically impractical.
- Legitimate users who mistype once or twice experience no lockout. The threshold (default: 5 attempts) provides room for honest mistakes.
- Dual tracking (IP + identifier) catches both single-source attacks (one IP, many usernames) and distributed attacks (many IPs, one username). Both dimensions must be clear before authentication proceeds.
- The progressive multiplier is configurable. Setting it to 1.0 disables progression and reverts to fixed-duration lockout. This allows operators to tune the aggressiveness based on their threat model.
- A `maxLockoutDuration` cap (default 24 hours) prevents pathological lockout durations. Without the cap, exponential growth could theoretically lock out keys for years after enough attempts.
- An administrative lockout clearing API is provided (`LockoutResource`) for operational recovery when legitimate users are locked out.

**Evidence in code:**

- `api/src/main/java/aussie/core/service/auth/AuthRateLimitService.java` -- Progressive lockout implementation:
  - `calculateProgressiveLockout(int previousLockouts)`: `base * multiplier^lockoutCount`, capped at `maxLockoutDuration` (lines 239-255)
  - `recordAttemptAndMaybeLockout()`: checks threshold, fetches lockout count, calculates progressive duration (lines 215-237)
  - Dual tracking with `IP_PREFIX` and `USER_PREFIX`/`API_KEY_PREFIX` key prefixes (lines 44-46)
  - `clearFailedAttempts()` on successful authentication (lines 264-284)
- `api/src/main/java/aussie/core/config/AuthRateLimitConfig.java` -- Configuration interface:
  - `maxFailedAttempts()` default 5 (line 47)
  - `lockoutDuration()` default 15 minutes (line 58)
  - `progressiveLockoutMultiplier()` default 1.5 with documented escalation example (lines 94-109)
  - `maxLockoutDuration()` default 24 hours (line 120)
  - `failedAttemptWindow()` default 1 hour for automatic recovery (line 69)
- `api/src/main/java/aussie/system/filter/AuthRateLimitFilter.java` -- JAX-RS filter that invokes the service before authentication
- `api/src/main/java/aussie/adapter/in/rest/LockoutResource.java` -- Administrative API for clearing lockouts

---

## ADR-010: Default-Deny Visibility Instead of Default-Public

**Status:** Accepted

**Context:** When a new service registers with the gateway, its endpoints need a default visibility setting. The choice between default-public and default-private has significant security implications. Default-public means that any endpoint a service exposes is immediately accessible from the internet unless someone remembers to mark it private. Default-private means endpoints are locked down until explicitly opened. In a large organization with many teams registering services, the probability that someone forgets to configure visibility is high.

**Decision:** Default all endpoints to `PRIVATE` visibility. The `ServiceRegistration` compact constructor sets `defaultVisibility = EndpointVisibility.PRIVATE` when null. The gateway enforces a policy-level guardrail that rejects any registration attempting to set `defaultVisibility` to `PUBLIC` unless the gateway administrator has explicitly enabled the `publicDefaultVisibilityEnabled` flag. Services that need public endpoints must explicitly mark them via visibility rules or endpoint configuration.

**Consequences:**
- New services are secure by default. A developer who registers a service without thinking about visibility gets a locked-down service, not an exposed one.
- The gateway-level guardrail (`publicDefaultVisibilityEnabled = false` by default) means that even if a service tries to register with `PUBLIC` default visibility, the request is rejected with a 403 and a message directing the developer to contact their gateway administrator. This prevents accidental exposure.
- Services that need mixed visibility (some public, some private endpoints) configure this through `VisibilityRule` patterns or per-endpoint `EndpointConfig.visibility` settings. The first matching rule wins, with the service's `defaultVisibility` as the fallback.
- This creates friction for internal-only deployments where all endpoints should be public. The administrator must set `publicDefaultVisibilityEnabled = true` to allow public defaults. This is deliberate -- the friction ensures the decision is conscious.

**Evidence in code:**

- `api/src/main/java/aussie/core/model/service/ServiceRegistration.java` -- Default visibility in compact constructor:
  - `if (defaultVisibility == null) { defaultVisibility = EndpointVisibility.PRIVATE; }` (lines 81-83)
- `api/src/main/java/aussie/core/model/routing/EndpointVisibility.java` -- Enum with two values: `PUBLIC`, `PRIVATE` (lines 3-13)
- `api/src/main/java/aussie/core/model/auth/GatewaySecurityConfig.java` -- Core port interface:
  - `publicDefaultVisibilityEnabled()` method (line 13)
- `api/src/main/java/aussie/adapter/out/http/SecurityConfig.java` -- Adapter implementation:
  - `@WithDefault("false") boolean publicDefaultVisibilityEnabled()` (lines 17-19)
- `api/src/main/java/aussie/core/service/routing/ServiceRegistrationValidator.java` -- Policy enforcement:
  - Rejects `PUBLIC` default visibility when `publicDefaultVisibilityEnabled` is false with a 403 (lines 33-41)
- `api/src/main/java/aussie/core/model/auth/VisibilityRule.java` -- Pattern-based visibility overrides with `publicRule()` and `privateRule()` factory methods (lines 11-68)
- `api/src/main/java/aussie/core/service/routing/VisibilityResolver.java` -- First-match rule evaluation with service default as fallback (lines 31-41)

---

## ADR-011: ConfigProducer Bridging Pattern Instead of Direct @ConfigMapping Injection

**Status:** Accepted

**Context:** Quarkus uses `@ConfigMapping` interfaces to bind configuration properties to typed interfaces. The gateway's adapter layer defines `GatewayConfig` with nested sub-interfaces (`LimitsConfig`, `AccessControlConfig`, `SecurityConfig`, etc.). The core layer defines its own configuration interfaces (e.g., `GatewaySecurityConfig`, `AccessControlConfig`) that are framework-free -- they do not import `@ConfigMapping` or any Quarkus annotation. The core layer cannot depend on the adapter layer (enforced by ArchUnit), so core services cannot inject the adapter's `GatewayConfig` directly.

**Decision:** Create a `ConfigProducer` in the adapter layer that takes the adapter's `GatewayConfig` via constructor injection and produces individual core-layer configuration beans via `@Produces` methods. Each method unwraps a nested config sub-interface and exposes it as a CDI bean typed to the core interface.

**Consequences:**
- Core services inject their configuration interfaces (`LimitsConfig`, `AccessControlConfig`, `GatewaySecurityConfig`) without knowing those interfaces are backed by Quarkus `@ConfigMapping`. The core layer remains framework-free.
- Configuration is produced once at startup (`@ApplicationScoped`) and shared across all consumers. There is no per-injection overhead.
- This works because the adapter's config sub-interfaces extend the core interfaces. For example, `SecurityConfig extends GatewaySecurityConfig` and adds the `@WithDefault("false")` annotation. CDI produces the adapter implementation, but consumers see only the core type.
- Adding a new configuration concern requires three changes: (1) define the core interface, (2) extend it in the adapter config, (3) add a `@Produces` method in `ConfigProducer`. This is more ceremony than direct `@ConfigMapping` injection, but the indirection keeps the core layer clean.

**Evidence in code:**

- `api/src/main/java/aussie/adapter/out/http/ConfigProducer.java` -- Bridge class:
  - Constructor-injects `GatewayConfig` (line 22)
  - `@Produces` methods for `LimitsConfig`, `AccessControlConfig`, `GatewaySecurityConfig`, `TrustedProxyConfig` (lines 26-48)
- `api/src/main/java/aussie/adapter/out/http/GatewayConfig.java` -- Adapter-layer config:
  - `@ConfigMapping(prefix = "aussie.gateway")` (line 9)
  - Returns nested sub-interfaces: `forwarding()`, `limits()`, `accessControl()`, `security()`, `trustedProxy()` (lines 12-20)
- `api/src/main/java/aussie/adapter/out/http/SecurityConfig.java` -- Adapter sub-interface:
  - `extends GatewaySecurityConfig` (line 11)
  - Adds `@WithDefault("false")` to `publicDefaultVisibilityEnabled()` (lines 17-19)
- `api/src/main/java/aussie/core/model/auth/GatewaySecurityConfig.java` -- Core interface (framework-free):
  - Pure Java interface with `publicDefaultVisibilityEnabled()` (line 13)

---

## ADR-012: Reactive (Mutiny Uni/Multi) Throughout Instead of Blocking APIs

**Status:** Accepted

**Context:** An API gateway is I/O-bound by nature. It receives a request, authenticates it (potentially hitting Redis or an OIDC provider), checks rate limits (Redis), resolves the route (local cache or Cassandra), proxies the request to an upstream service (HTTP client), and returns the response. If any of these steps blocks a thread, the gateway's throughput is limited by the thread pool size. In a Quarkus + Vert.x stack, blocking a Vert.x event loop thread is a critical error that degrades all concurrent requests on that event loop.

**Decision:** Use Smallrye Mutiny `Uni<T>` and `Multi<T>` as the return types for all I/O-touching interfaces and services. Port interfaces in `core/port/out/` return `Uni<T>` for single-value operations and `Multi<T>` for streaming operations. Core services compose these into reactive pipelines using `flatMap`, `map`, `chain`, and `call`.

**Consequences:**
- No thread is ever blocked waiting for I/O. The gateway can handle thousands of concurrent connections with a small number of event loop threads (typically equal to CPU cores).
- The reactive programming model is pervasive. It is not optional or limited to the adapter layer. Core service methods like `ServiceRegistry.register()` return `Uni<RegistrationResult>`, and callers must compose reactively.
- Debugging reactive pipelines is harder than debugging sequential code. Stack traces show Mutiny operators rather than business method calls. The team addresses this by keeping individual pipeline stages short and well-named.
- Error handling uses `.onFailure()` operators rather than try-catch blocks, which requires a different mental model. Exceptions propagate through the Uni/Multi chain rather than unwinding the call stack.
- Testing is straightforward because Mutiny provides `Uni.createFrom().item()` and `Uni.createFrom().failure()` for creating test values, and `UniAssertSubscriber` for assertions.

**Evidence in code:**

- `api/src/main/java/aussie/core/port/out/ProxyClient.java` -- `Uni<ProxyResponse> forward(PreparedProxyRequest request)` (line 10)
- `api/src/main/java/aussie/core/port/in/GatewayUseCase.java` -- `Uni<GatewayResult> forward(GatewayRequest request)` (line 22)
- `api/src/main/java/aussie/core/port/out/ServiceRegistrationRepository.java` -- Repository port returning `Uni<List<ServiceRegistration>>`, `Uni<Optional<ServiceRegistration>>`, etc.
- `api/src/main/java/aussie/core/service/routing/ServiceRegistry.java` -- Reactive service:
  - `register()` returns `Uni<RegistrationResult>` and chains `repository.findById().flatMap(...)` (lines 213-275)
  - `findRouteAsync()` chains `ensureCacheFresh().map(...)` (line 434-435)
- `api/src/main/java/aussie/core/service/auth/AuthRateLimitService.java` -- Reactive composition:
  - `checkAuthLimit()` chains `checkLockout()` via `flatMap` (lines 64-88)
  - `recordAttemptAndMaybeLockout()` chains `recordFailedAttempt().flatMap()` with nested `getLockoutCount().flatMap()` (lines 215-237)
- `api/src/main/java/aussie/core/service/auth/TokenRevocationService.java` -- Multi-tier reactive chain through bloom filter, cache, and remote store (lines 70-116)
- `api/src/main/java/aussie/system/filter/RateLimitFilter.java` -- `@ServerRequestFilter` returning `Uni<Response>` (line 102)

---

## ADR-013: Connection Pooling as Bulkhead Pattern

**Status:** Accepted

**Context:** The gateway depends on multiple external systems: Cassandra for persistent storage, Redis for caching and rate limiting, upstream HTTP services for proxying, and OIDC providers for JWKS fetching. If one dependency becomes slow (e.g., Cassandra is experiencing a compaction storm), unbounded connection usage can cascade: the slow dependency consumes all available connections or threads, starving other dependencies and ultimately making the gateway unresponsive to all traffic.

**Decision:** Treat connection pools as bulkheads. Each external dependency has an independently sized and bounded connection pool. The pool sizes are configurable through `ResiliencyConfig`. A dedicated health check (`BulkheadHealthCheck`) reports the configured limits, and `BulkheadMetrics` exposes them as Micrometer gauges for alerting.

**Consequences:**
- Failure is isolated. If Cassandra is slow, only Cassandra operations are affected (queuing behind their pool limit). Redis, HTTP proxy, and JWKS operations continue unimpacted because they have their own pools.
- The pool sizes serve as backpressure mechanisms. When a pool is exhausted, new requests for that dependency queue (up to a configurable waiting limit) or fail fast, rather than consuming unbounded resources.
- Pool sizing requires capacity planning. The defaults (`cassandra.poolLocalSize=30`, `redis.poolSize=30`, `http.maxConnectionsPerHost=50`, `http.maxConnections=200`, `jwks.maxConnections=10`) are reasonable starting points, but production deployments need tuning based on observed traffic patterns.
- The health check intentionally reports UP even when pools are under pressure. The documentation explains that transient pool exhaustion is expected under load and should trigger alerts via metrics (80-90% sustained occupancy), not mark the service as unhealthy for the load balancer.
- Redis has an additional `poolWaiting` parameter (default 100) that limits how many requests can queue when the pool is exhausted, providing an explicit backpressure boundary.

**Evidence in code:**

- `api/src/main/java/aussie/core/config/ResiliencyConfig.java` -- Central configuration:
  - `HttpConfig`: `maxConnectionsPerHost=50`, `maxConnections=200`, `connectTimeout=5s`, `requestTimeout=30s` (lines 47-82)
  - `JwksConfig`: `maxConnections=10`, `fetchTimeout=5s`, `cacheTtl=1h` (lines 87-127)
  - `CassandraConfig`: `poolLocalSize=30`, `maxRequestsPerConnection=1024`, `queryTimeout=5s` (lines 132-159)
  - `RedisConfig`: `poolSize=30`, `poolWaiting=100`, `operationTimeout=1s` with per-operation-type fail-open/fail-closed documentation (lines 164-197)
- `api/src/main/java/aussie/adapter/in/health/BulkheadHealthCheck.java` -- Readiness check:
  - Reports all bulkhead limits as health data (lines 57-63)
  - Javadoc explains why it always reports UP (lines 26-31)
  - Documents the threading model: event loop for CPU work, IO pools as isolated bulkheads (lines 33-38)
- `api/src/main/java/aussie/adapter/out/telemetry/BulkheadMetrics.java` -- Micrometer gauges:
  - Registers `aussie.bulkhead.{cassandra,redis,http,jwks}.pool.max` gauges (lines 88-121)
  - Tags with `type` for filtering: `connection_pool`, `request_limit`, `queue_limit` (lines 90-106)
- `api/src/main/java/aussie/adapter/out/http/ProxyHttpClient.java` -- HTTP pool usage:
  - `WebClientOptions.setConnectTimeout()` from `httpConfig` (line 82)
  - Per-request timeout from `httpConfig.requestTimeout()` (line 216)

---

## ADR-014: Request Coalescing for Cache Refresh

**Status:** Accepted

**Context:** When a local cache entry expires in a multi-instance gateway, the next request triggers a refresh from persistent storage. Under load, many concurrent requests may arrive between the moment the cache becomes stale and the moment the refresh completes. Without coordination, each concurrent request triggers its own independent refresh -- a "thundering herd" against the storage backend. This is distinct from the jitter-based cache stampede prevention in ADR-004, which spreads expiration times. This addresses the window between expiration and refresh completion on a single instance.

**Decision:** Implement request coalescing (also known as "single flight") for cache refresh operations. When the cache is stale and a refresh is needed, the first request creates a new `Uni` for the refresh and stores it in an `AtomicReference`. Subsequent requests that arrive while the refresh is in flight join the existing `Uni` rather than creating their own. When the refresh completes, the reference is cleared. The `Uni` is memoized so all subscribers receive the same result.

**Consequences:**
- No matter how many concurrent requests hit a stale cache, exactly one storage query is issued. All other requests wait on the same reactive pipeline and receive the result when it completes.
- The implementation uses lock-free concurrency (`AtomicReference.compareAndSet`) rather than synchronized blocks, avoiding contention on the event loop.
- If the in-flight refresh fails, the error propagates to all waiting subscribers. The next request after the failure will attempt a new refresh. There is no retry loop -- the caller's error handling determines what happens.
- The pattern is applied in two places: `ServiceRegistry` for route cache refresh, and `JwksCacheService` for JWKS key set fetching. Both use the same structural pattern (ConcurrentHashMap or AtomicReference of in-flight Uni, memoize, clear on termination) but are implemented independently rather than abstracted into a shared utility. This is a conscious trade-off of DRY against simplicity.

**Evidence in code:**

- `api/src/main/java/aussie/core/service/routing/ServiceRegistry.java` -- Route cache coalescing:
  - `AtomicReference<Uni<Void>> inFlightRefresh` field (line 68)
  - `ensureCacheFresh()` method: double-check stale, join existing or create new, `compareAndSet` for race safety, `.memoize().indefinitely()`, clear on termination (lines 138-169)
  - Javadoc: "Uses request coalescing to prevent thundering herd" (lines 134-135)
- `api/src/main/java/aussie/core/service/auth/JwksCacheService.java` -- JWKS fetch coalescing:
  - `Map<URI, Uni<JsonWebKeySet>> inFlightFetches` field (line 51)
  - `getOrCreateFetch()`: uses `computeIfAbsent` to ensure single fetch per URI (lines 87-93)
  - `createFetch()`: `.memoize().indefinitely()`, clear `inFlightFetches` on termination (lines 95-101)
  - Javadoc: "Thundering herd protection via request coalescing" (line 39)
  - Stale cache fallback: if the refresh fails, returns stale cached keys if available (lines 144-153)
